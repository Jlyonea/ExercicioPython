# -*- coding: utf-8 -*-
"""Untitled1.ipynb.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-B1sQQNifgIIXz-upVMgQhIid0-M_4e1
"""

from random import seed
from random import randint
import time
import sys
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

sys.setrecursionlimit(10 ** 9)

def partition(colecao, l, h):
    i = ( l - 1 )
    x = colecao[h]
 
    for j in range(l, h):
        if   colecao[j] <= x:

            i = i + 1
            colecao[i], colecao[j] = colecao[j], colecao[i]
 
    colecao[i + 1], colecao[h] = colecao[h], colecao[i + 1]
    return (i + 1)
 
def PeG(tamanho, tempoI = list, tempoR = list, contador = 0):

    dados = {"Tamanho da lista": tamanho, "solução recursiva": tempoR,
    "solução iterativa": tempoI,}

    planilha = pd.DataFrame.from_dict(dados)
    planilha.to_excel("Soluçõesaps.xlsx")

    if contador == 1:
        Y = tamanho
        X = tempoR
        plt.bar(X, Y, color = "yellow")

        plt.title("Tempo de solução da recursiva")
        plt.xlabel("Tempo")
        plt.ylabel("Quantidade de numeros da lista")
        plt.savefig("Grafico da recursiva.png")
        plt.show()
    else:
        Y = tamanho
        X = tempoI
        plt.bar(X, Y, color = "purple")

        plt.title("Tempo de solução da iterativa")
        plt.xlabel("Tempo em segundos")
        plt.ylabel("Quantidade numeros da Lista")
        plt.savefig("Grafico da iterativa.png")
        plt.show()


def quickSortIterative(colecao, l, h):
 
    size = h - l + 1
    stack = [0] * (size)
 
    top = -1
 
    top = top + 1
    stack[top] = l
    top = top + 1
    stack[top] = h
 
    while top >= 0:
 
        h = stack[top]
        top = top - 1
        l = stack[top]
        top = top - 1
 
        p = partition( colecao, l, h )
 
        if p-1 > l:
            top = top + 1
            stack[top] = l
            top = top + 1
            stack[top] = p - 1
 
        if p + 1 < h:
            top = top + 1
            stack[top] = p + 1
            top = top + 1
            stack[top] = h


def partition(colecao, low, high):
    i = (low - 1)        
    pivot = colecao[high]    
 
    for j in range(low, high):
        if colecao[j] <= pivot:
            i += 1
            colecao[i], colecao[j] = colecao[j], colecao[i]
 
    colecao[i + 1], colecao[high] = colecao[high], colecao[i + 1]
    return (i + 1)
 
def quickSortRecursive(colecao, low, high):
    if low < high:
 
        pi = partition(colecao, low, high)
 
        quickSortRecursive(colecao, low, pi-1)
        quickSortRecursive(colecao, pi + 1, high)

  

def criarColecao(colecao, tamanho):
     for indice in range(0, tamanho):
        valor = np.int64(randint(0, 51))
        colecao.append(valor)

def main():
    tamanhos = [500,10000, 25000]
    TAMANHO = 0
    colecao = []

    tamanholista = []
    tempoR = []
    tempoI = []

    loop = 0
    print()
        
    while loop != len(tamanhos):

        TAMANHO = tamanhos[loop]

        tamanholista.append(TAMANHO)

        criarColecao(colecao,  TAMANHO)

        listarecursiva = colecao.copy()
        listaiterativa = colecao.copy()

        tempoInicial = time.time() 
        quickSortRecursive(listarecursiva, 0, TAMANHO - 1)
        tempoFinal = time.time()

        tempoTotal = tempoFinal-tempoInicial
        tempoR.append(tempoTotal)

        print("Tempo da solução recursiva: {} s".format(tempoFinal - tempoInicial))

        tempoInicial = time.time() 
        quickSortIterative(listaiterativa, 0, TAMANHO - 1) 
        tempoFinal = time.time()

        tempoTotal = tempoFinal-tempoInicial
        tempoI.append(tempoTotal)

        print("Tempo da solução Iterativa: {} s".format(tempoFinal - tempoInicial))
        print()

        loop +=1

    PeG(tamanholista, tempoI, tempoR,)
    PeG(tamanholista, tempoI, tempoR, 1)
if __name__ == '__main__' :
    main()

